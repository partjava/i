"use client";
import { useState } from "react";
import Link from "next/link";

export default function MalwareAnalysisPage() {
  const [activeTab, setActiveTab] = useState("overview");

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">恶意代码分析</h1>
      
      {/* 标签页导航 */}
      <div className="flex space-x-4 mb-6 border-b overflow-x-auto">
        <button
          onClick={() => setActiveTab("overview")}
          className={`px-4 py-2 font-medium whitespace-nowrap ${
            activeTab === "overview"
              ? "border-b-2 border-blue-500 text-blue-600"
              : "text-gray-500 hover:text-gray-700"
          }`}
        >
          概述
        </button>
        <button
          onClick={() => setActiveTab("analysis")}
          className={`px-4 py-2 font-medium whitespace-nowrap ${
            activeTab === "analysis"
              ? "border-b-2 border-blue-500 text-blue-600"
              : "text-gray-500 hover:text-gray-700"
          }`}
        >
          分析方法
        </button>
        <button
          onClick={() => setActiveTab("tools")}
          className={`px-4 py-2 font-medium whitespace-nowrap ${
            activeTab === "tools"
              ? "border-b-2 border-blue-500 text-blue-600"
              : "text-gray-500 hover:text-gray-700"
          }`}
        >
          工具使用
        </button>
        <button
          onClick={() => setActiveTab("practice")}
          className={`px-4 py-2 font-medium whitespace-nowrap ${
            activeTab === "practice"
              ? "border-b-2 border-blue-500 text-blue-600"
              : "text-gray-500 hover:text-gray-700"
          }`}
        >
          实践案例
        </button>
      </div>

      {/* 内容区域 */}
      <div className="space-y-6">
        {activeTab === "overview" && (
          <div className="space-y-6">
            <h3 className="text-xl font-semibold mb-3">恶意代码分析概述</h3>
            <div className="prose max-w-none">
              <h4 className="font-semibold">1. 什么是恶意代码分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <p className="mb-4">
                  恶意代码分析是指对恶意软件进行深入分析，以了解其功能、行为特征、传播方式以及危害程度的过程。这种分析对于安全防护、威胁情报和事件响应都至关重要。
                </p>

                <h5 className="font-semibold mb-2">主要目标</h5>
                <ul className="list-disc pl-6 mb-4">
                  <li>行为分析
                    <ul className="list-disc pl-6 mt-2">
                      <li>识别恶意行为</li>
                      <li>分析传播方式</li>
                      <li>评估危害程度</li>
                      <li>确定攻击目标</li>
                    </ul>
                  </li>
                  <li>技术分析
                    <ul className="list-disc pl-6 mt-2">
                      <li>分析代码结构</li>
                      <li>识别加密算法</li>
                      <li>分析通信协议</li>
                      <li>提取特征码</li>
                    </ul>
                  </li>
                  <li>防护措施
                    <ul className="list-disc pl-6 mt-2">
                      <li>制定防护策略</li>
                      <li>开发检测规则</li>
                      <li>提供清除方案</li>
                      <li>更新安全策略</li>
                    </ul>
                  </li>
                </ul>
              </div>

              <h4 className="font-semibold">2. 常见恶意代码类型</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <ul className="list-disc pl-6 mb-4">
                  <li>病毒
                    <ul className="list-disc pl-6 mt-2">
                      <li>文件感染型</li>
                      <li>引导区型</li>
                      <li>宏病毒</li>
                      <li>脚本病毒</li>
                    </ul>
                  </li>
                  <li>蠕虫
                    <ul className="list-disc pl-6 mt-2">
                      <li>网络传播型</li>
                      <li>邮件传播型</li>
                      <li>即时通讯型</li>
                      <li>P2P传播型</li>
                    </ul>
                  </li>
                  <li>木马
                    <ul className="list-disc pl-6 mt-2">
                      <li>远程控制型</li>
                      <li>信息窃取型</li>
                      <li>下载器型</li>
                      <li>代理服务器型</li>
                    </ul>
                  </li>
                  <li>勒索软件
                    <ul className="list-disc pl-6 mt-2">
                      <li>文件加密型</li>
                      <li>系统锁定型</li>
                      <li>数据窃取型</li>
                      <li>混合型</li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        )}

        {activeTab === "analysis" && (
          <div className="space-y-6">
            <h3 className="text-xl font-semibold mb-3">分析方法</h3>
            <div className="prose max-w-none">
              <h4 className="font-semibold">1. 静态分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <h5 className="font-semibold mb-2">文件分析</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 文件特征分析示例
class FileAnalyzer {
private:
    // 文件头分析
    bool analyzeHeader(const char* filename) {
        // 检查文件类型
        // 检查文件头特征
        // 检查文件结构
        return true;
    }
    
    // 字符串分析
    bool analyzeStrings(const char* filename) {
        // 提取ASCII字符串
        // 提取Unicode字符串
        // 分析关键字符串
        return true;
    }
    
    // 资源分析
    bool analyzeResources(const char* filename) {
        // 提取资源
        // 分析图标
        // 分析版本信息
        return true;
    }
    
public:
    // 执行文件分析
    bool analyze(const char* filename) {
        if (!analyzeHeader(filename)) return false;
        if (!analyzeStrings(filename)) return false;
        if (!analyzeResources(filename)) return false;
        return true;
    }
};`}</code>
                </pre>

                <h5 className="font-semibold mb-2">代码分析</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 代码分析示例
class CodeAnalyzer {
private:
    // 反汇编分析
    bool analyzeDisassembly(const char* filename) {
        // 反汇编代码
        // 分析指令序列
        // 识别关键函数
        return true;
    }
    
    // 控制流分析
    bool analyzeControlFlow() {
        // 构建控制流图
        // 分析跳转关系
        // 识别关键路径
        return true;
    }
    
    // 数据流分析
    bool analyzeDataFlow() {
        // 跟踪数据流
        // 分析变量使用
        // 识别敏感操作
        return true;
    }
    
public:
    // 执行代码分析
    bool analyze(const char* filename) {
        if (!analyzeDisassembly(filename)) return false;
        if (!analyzeControlFlow()) return false;
        if (!analyzeDataFlow()) return false;
        return true;
    }
};`}</code>
                </pre>
              </div>

              <h4 className="font-semibold">2. 动态分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <h5 className="font-semibold mb-2">行为监控</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 行为监控示例
class BehaviorMonitor {
private:
    // 文件操作监控
    bool monitorFileOperations() {
        // 监控文件创建
        // 监控文件修改
        // 监控文件删除
        return true;
    }
    
    // 注册表监控
    bool monitorRegistry() {
        // 监控注册表读取
        // 监控注册表写入
        // 监控注册表删除
        return true;
    }
    
    // 网络监控
    bool monitorNetwork() {
        // 监控网络连接
        // 监控数据传输
        // 监控DNS查询
        return true;
    }
    
public:
    // 执行行为监控
    bool monitor(const char* filename) {
        // 启动监控
        // 运行样本
        // 记录行为
        return true;
    }
};`}</code>
                </pre>

                <h5 className="font-semibold mb-2">内存分析</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 内存分析示例
class MemoryAnalyzer {
private:
    // 进程内存分析
    bool analyzeProcessMemory() {
        // 分析内存布局
        // 提取关键数据
        // 分析内存特征
        return true;
    }
    
    // 堆分析
    bool analyzeHeap() {
        // 分析堆分配
        // 跟踪内存使用
        // 检测内存泄漏
        return true;
    }
    
    // 代码注入检测
    bool detectCodeInjection() {
        // 检测代码注入
        // 分析注入代码
        // 跟踪执行流程
        return true;
    }
    
public:
    // 执行内存分析
    bool analyze(const char* processName) {
        // 附加到进程
        // 执行分析
        // 生成报告
        return true;
    }
};`}</code>
                </pre>
              </div>
            </div>
          </div>
        )}

        {activeTab === "tools" && (
          <div className="space-y-6">
            <h3 className="text-xl font-semibold mb-3">工具使用</h3>
            <div className="prose max-w-none">
              <h4 className="font-semibold">1. 静态分析工具</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <h5 className="font-semibold mb-2">IDA Pro</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`# IDA Pro基本操作
# 1. 加载文件
File -> Open -> 选择文件

# 2. 分析选项
Options -> General -> Analysis
Options -> General -> Disassembly

# 3. 常用快捷键
Space - 切换图形/文本视图
N - 重命名
X - 查看交叉引用
Y - 修改类型
P - 创建函数
C - 创建代码
D - 切换数据显示格式`}</code>
                </pre>

                <h5 className="font-semibold mb-2">Ghidra</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`# Ghidra基本操作
# 1. 创建项目
File -> New Project

# 2. 导入文件
File -> Import File

# 3. 分析选项
Analysis -> One Shot
Analysis -> Auto Analysis

# 4. 常用功能
Window -> Symbol Table
Window -> Data Type Manager
Window -> Decompiler`}</code>
                </pre>
              </div>

              <h4 className="font-semibold">2. 动态分析工具</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <h5 className="font-semibold mb-2">Process Monitor</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`# Process Monitor使用
# 1. 过滤设置
Filter -> Filter...
- Process Name is malware.exe
- Operation is CreateFile
- Operation is RegCreateKey

# 2. 监控选项
Options -> Enable Boot Logging
Options -> Enable Advanced Output
Options -> Show Profiling Events

# 3. 数据导出
File -> Save
- 选择CSV格式
- 选择XML格式
- 选择PML格式`}</code>
                </pre>

                <h5 className="font-semibold mb-2">Wireshark</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`# Wireshark使用
# 1. 捕获设置
Capture -> Options
- 选择网卡
- 设置过滤器
- 设置缓冲区

# 2. 显示过滤
- ip.addr == 192.168.1.1
- tcp.port == 80
- http.request.method == POST

# 3. 数据导出
File -> Export
- 选择PCAP格式
- 选择CSV格式
- 选择JSON格式`}</code>
                </pre>
              </div>
            </div>
          </div>
        )}

        {activeTab === "practice" && (
          <div className="space-y-6">
            <h3 className="text-xl font-semibold mb-3">实践案例</h3>
            <div className="prose max-w-none">
              <h4 className="font-semibold">1. 勒索软件分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 勒索软件分析示例代码
class RansomwareAnalyzer {
private:
    // 文件加密分析
    struct EncryptionInfo {
        std::string algorithm;
        std::string key;
        std::vector<std::string> targetExtensions;
    };
    
    // 分析加密算法
    EncryptionInfo analyzeEncryption(const char* filename) {
        EncryptionInfo info;
        // 1. 识别加密算法
        // 2. 提取加密密钥
        // 3. 分析目标文件类型
        return info;
    }
    
    // 分析网络通信
    struct NetworkInfo {
        std::string c2Server;
        std::string protocol;
        std::string encryption;
    };
    
    NetworkInfo analyzeNetwork(const char* filename) {
        NetworkInfo info;
        // 1. 提取C2服务器地址
        // 2. 分析通信协议
        // 3. 分析通信加密
        return info;
    }
    
    // 分析勒索信息
    struct RansomInfo {
        std::string message;
        std::string paymentMethod;
        std::string contactInfo;
    };
    
    RansomInfo analyzeRansomInfo(const char* filename) {
        RansomInfo info;
        // 1. 提取勒索信息
        // 2. 分析支付方式
        // 3. 分析联系方式
        return info;
    }
    
public:
    // 执行勒索软件分析
    bool analyze(const char* filename) {
        // 1. 静态分析
        EncryptionInfo encInfo = analyzeEncryption(filename);
        NetworkInfo netInfo = analyzeNetwork(filename);
        RansomInfo ransomInfo = analyzeRansomInfo(filename);
        
        // 2. 动态分析
        // 监控文件操作
        // 监控网络通信
        // 监控注册表操作
        
        // 3. 生成分析报告
        generateReport(encInfo, netInfo, ransomInfo);
        return true;
    }
};`}</code>
                </pre>
              </div>

              <h4 className="font-semibold">2. 远控木马分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 远控木马分析示例代码
class RATAnalyzer {
private:
    // 命令分析
    struct CommandInfo {
        std::string command;
        std::string handler;
        std::string parameters;
    };
    
    // 分析控制命令
    std::vector<CommandInfo> analyzeCommands(const char* filename) {
        std::vector<CommandInfo> commands;
        // 1. 提取命令列表
        // 2. 分析命令处理函数
        // 3. 分析命令参数
        return commands;
    }
    
    // 持久化分析
    struct PersistenceInfo {
        std::string method;
        std::string location;
        std::string trigger;
    };
    
    PersistenceInfo analyzePersistence(const char* filename) {
        PersistenceInfo info;
        // 1. 分析持久化方法
        // 2. 分析持久化位置
        // 3. 分析触发条件
        return info;
    }
    
    // 通信分析
    struct CommunicationInfo {
        std::string protocol;
        std::string encryption;
        std::string c2Server;
    };
    
    CommunicationInfo analyzeCommunication(const char* filename) {
        CommunicationInfo info;
        // 1. 分析通信协议
        // 2. 分析通信加密
        // 3. 分析C2服务器
        return info;
    }
    
    // 反检测分析
    struct AntiDetectionInfo {
        std::vector<std::string> techniques;
        std::vector<std::string> targets;
    };
    
    AntiDetectionInfo analyzeAntiDetection(const char* filename) {
        AntiDetectionInfo info;
        // 1. 分析反检测技术
        // 2. 分析检测目标
        return info;
    }
    
public:
    // 执行远控木马分析
    bool analyze(const char* filename) {
        // 1. 静态分析
        auto commands = analyzeCommands(filename);
        auto persistence = analyzePersistence(filename);
        auto communication = analyzeCommunication(filename);
        auto antiDetection = analyzeAntiDetection(filename);
        
        // 2. 动态分析
        // 监控进程创建
        // 监控网络连接
        // 监控文件操作
        // 监控注册表操作
        
        // 3. 生成分析报告
        generateReport(commands, persistence, communication, antiDetection);
        return true;
    }
};`}</code>
                </pre>
              </div>

              <h4 className="font-semibold">3. 恶意代码分析工具示例</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 恶意代码分析工具示例
class MalwareAnalyzer {
private:
    // 文件特征分析
    struct FileFeatures {
        std::string fileType;
        std::string compiler;
        std::string packer;
        std::vector<std::string> imports;
    };
    
    FileFeatures analyzeFileFeatures(const char* filename) {
        FileFeatures features;
        // 1. 分析文件类型
        // 2. 识别编译器
        // 3. 检测加壳
        // 4. 分析导入表
        return features;
    }
    
    // 行为分析
    struct BehaviorInfo {
        std::vector<std::string> fileOperations;
        std::vector<std::string> registryOperations;
        std::vector<std::string> networkConnections;
    };
    
    BehaviorInfo analyzeBehavior(const char* filename) {
        BehaviorInfo info;
        // 1. 监控文件操作
        // 2. 监控注册表操作
        // 3. 监控网络连接
        return info;
    }
    
    // 内存分析
    struct MemoryInfo {
        std::vector<std::string> loadedModules;
        std::vector<std::string> injectedProcesses;
        std::vector<std::string> suspiciousPatterns;
    };
    
    MemoryInfo analyzeMemory(const char* processName) {
        MemoryInfo info;
        // 1. 分析加载模块
        // 2. 检测进程注入
        // 3. 识别可疑模式
        return info;
    }
    
public:
    // 执行恶意代码分析
    bool analyze(const char* filename) {
        // 1. 文件分析
        auto features = analyzeFileFeatures(filename);
        
        // 2. 行为分析
        auto behavior = analyzeBehavior(filename);
        
        // 3. 内存分析
        auto memory = analyzeMemory(filename);
        
        // 4. 生成分析报告
        generateReport(features, behavior, memory);
        return true;
    }
};`}</code>
                </pre>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* 导航链接 */}
      <div className="mt-8 flex justify-between">
        <Link
          href="/study/security/reverse/vulnerability"
          className="px-4 py-2 text-blue-600 hover:text-blue-800"
        >
          ← 漏洞挖掘
        </Link>
        <Link
          href="/study/security/reverse/basic"
          className="px-4 py-2 text-blue-600 hover:text-blue-800"
        >
          逆向工程基础 →
        </Link>
      </div>
    </div>
  );
} 