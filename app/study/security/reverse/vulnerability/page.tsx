"use client";
import { useState } from "react";
import Link from "next/link";

export default function VulnerabilityPage() {
  const [activeTab, setActiveTab] = useState("overview");

  return (
    <div className="container mx-auto px-4 py-8">
      <h1 className="text-3xl font-bold mb-8">漏洞挖掘技术</h1>
      
      {/* 标签页导航 */}
      <div className="flex space-x-4 mb-6 border-b overflow-x-auto">
        <button
          onClick={() => setActiveTab("overview")}
          className={`px-4 py-2 font-medium whitespace-nowrap ${
            activeTab === "overview"
              ? "border-b-2 border-blue-500 text-blue-600"
              : "text-gray-500 hover:text-gray-700"
          }`}
        >
          概述
        </button>
        <button
          onClick={() => setActiveTab("techniques")}
          className={`px-4 py-2 font-medium whitespace-nowrap ${
            activeTab === "techniques"
              ? "border-b-2 border-blue-500 text-blue-600"
              : "text-gray-500 hover:text-gray-700"
          }`}
        >
          技术方法
        </button>
        <button
          onClick={() => setActiveTab("tools")}
          className={`px-4 py-2 font-medium whitespace-nowrap ${
            activeTab === "tools"
              ? "border-b-2 border-blue-500 text-blue-600"
              : "text-gray-500 hover:text-gray-700"
          }`}
        >
          工具使用
        </button>
        <button
          onClick={() => setActiveTab("practice")}
          className={`px-4 py-2 font-medium whitespace-nowrap ${
            activeTab === "practice"
              ? "border-b-2 border-blue-500 text-blue-600"
              : "text-gray-500 hover:text-gray-700"
          }`}
        >
          实践案例
        </button>
      </div>

      {/* 内容区域 */}
      <div className="space-y-6">
        {activeTab === "overview" && (
          <div className="space-y-6">
            <h3 className="text-xl font-semibold mb-3">漏洞挖掘概述</h3>
            <div className="prose max-w-none">
              <h4 className="font-semibold">1. 什么是漏洞挖掘</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <p className="mb-4">
                  漏洞挖掘是指通过分析程序代码、二进制文件或运行时的行为，发现软件中存在的安全漏洞的过程。这些漏洞可能被攻击者利用，导致系统被入侵或数据泄露。
                </p>

                <h5 className="font-semibold mb-2">主要目标</h5>
                <ul className="list-disc pl-6 mb-4">
                  <li>发现安全漏洞
                    <ul className="list-disc pl-6 mt-2">
                      <li>缓冲区溢出</li>
                      <li>整数溢出</li>
                      <li>格式化字符串</li>
                      <li>UAF漏洞</li>
                    </ul>
                  </li>
                  <li>分析漏洞成因
                    <ul className="list-disc pl-6 mt-2">
                      <li>代码逻辑错误</li>
                      <li>内存管理问题</li>
                      <li>输入验证不足</li>
                      <li>权限控制缺陷</li>
                    </ul>
                  </li>
                  <li>评估漏洞影响
                    <ul className="list-disc pl-6 mt-2">
                      <li>漏洞危害程度</li>
                      <li>利用难度</li>
                      <li>影响范围</li>
                      <li>修复建议</li>
                    </ul>
                  </li>
                </ul>
              </div>

              <h4 className="font-semibold">2. 常见漏洞类型</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <ul className="list-disc pl-6 mb-4">
                  <li>内存漏洞
                    <ul className="list-disc pl-6 mt-2">
                      <li>栈溢出</li>
                      <li>堆溢出</li>
                      <li>UAF漏洞</li>
                      <li>双重释放</li>
                    </ul>
                  </li>
                  <li>逻辑漏洞
                    <ul className="list-disc pl-6 mt-2">
                      <li>整数溢出</li>
                      <li>符号错误</li>
                      <li>条件竞争</li>
                      <li>权限提升</li>
                    </ul>
                  </li>
                  <li>输入验证漏洞
                    <ul className="list-disc pl-6 mt-2">
                      <li>格式化字符串</li>
                      <li>命令注入</li>
                      <li>SQL注入</li>
                      <li>XSS漏洞</li>
                    </ul>
                  </li>
                  <li>加密漏洞
                    <ul className="list-disc pl-6 mt-2">
                      <li>弱加密算法</li>
                      <li>密钥管理问题</li>
                      <li>随机数生成</li>
                      <li>密码学实现错误</li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        )}

        {activeTab === "techniques" && (
          <div className="space-y-6">
            <h3 className="text-xl font-semibold mb-3">技术方法</h3>
            <div className="prose max-w-none">
              <h4 className="font-semibold">1. 静态分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <h5 className="font-semibold mb-2">代码审计</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 代码审计示例
class CodeAuditor {
private:
    // 检查缓冲区操作
    bool checkBufferOperations(const char* code) {
        // 检查strcpy, strcat等危险函数
        // 检查数组边界检查
        // 检查内存分配和释放
        return true;
    }
    
    // 检查整数操作
    bool checkIntegerOperations(const char* code) {
        // 检查整数溢出
        // 检查符号错误
        // 检查类型转换
        return true;
    }
    
    // 检查格式化字符串
    bool checkFormatStrings(const char* code) {
        // 检查printf系列函数
        // 检查格式化字符串参数
        return true;
    }
    
public:
    // 执行代码审计
    bool audit(const char* filename) {
        // 读取源代码
        // 执行各项检查
        // 生成审计报告
        return true;
    }
};`}</code>
                </pre>

                <h5 className="font-semibold mb-2">符号执行</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 符号执行示例
class SymbolicExecutor {
private:
    // 符号变量
    struct SymbolicVariable {
        std::string name;
        std::string type;
        std::string constraints;
    };
    
    // 路径约束
    struct PathConstraint {
        std::string condition;
        bool isFeasible;
    };
    
    // 执行符号分析
    bool analyzeSymbolically(const char* code) {
        // 1. 提取符号变量
        // 2. 构建路径约束
        // 3. 求解约束条件
        // 4. 生成测试用例
        return true;
    }
    
public:
    // 执行符号执行
    bool execute(const char* filename) {
        // 读取程序
        // 执行符号分析
        // 生成报告
        return true;
    }
};`}</code>
                </pre>
              </div>

              <h4 className="font-semibold">2. 动态分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <h5 className="font-semibold mb-2">模糊测试</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 模糊测试示例
class Fuzzer {
private:
    // 测试用例生成
    struct TestCase {
        std::vector<uint8_t> data;
        std::string type;
    };
    
    // 生成测试数据
    TestCase generateTestCase() {
        // 1. 选择输入类型
        // 2. 生成随机数据
        // 3. 应用变异规则
        return TestCase();
    }
    
    // 执行测试
    bool runTest(const TestCase& testCase) {
        // 1. 准备测试环境
        // 2. 执行程序
        // 3. 监控异常
        // 4. 记录结果
        return true;
    }
    
public:
    // 执行模糊测试
    bool fuzz(const char* target) {
        // 1. 初始化
        // 2. 生成测试用例
        // 3. 执行测试
        // 4. 分析结果
        return true;
    }
};`}</code>
                </pre>

                <h5 className="font-semibold mb-2">动态污点分析</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 动态污点分析示例
class TaintAnalyzer {
private:
    // 污点源
    struct TaintSource {
        std::string type;
        std::string location;
    };
    
    // 污点传播
    bool propagateTaint() {
        // 1. 标记污点源
        // 2. 跟踪污点传播
        // 3. 检测敏感操作
        return true;
    }
    
    // 检测漏洞
    bool detectVulnerability() {
        // 1. 检查污点数据使用
        // 2. 分析操作类型
        // 3. 评估风险
        return true;
    }
    
public:
    // 执行污点分析
    bool analyze(const char* target) {
        // 1. 设置污点源
        // 2. 执行程序
        // 3. 分析结果
        return true;
    }
};`}</code>
                </pre>
              </div>
            </div>
          </div>
        )}

        {activeTab === "tools" && (
          <div className="space-y-6">
            <h3 className="text-xl font-semibold mb-3">工具使用</h3>
            <div className="prose max-w-none">
              <h4 className="font-semibold">1. 静态分析工具</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <h5 className="font-semibold mb-2">Clang Static Analyzer</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`# 使用Clang Static Analyzer
$ clang --analyze source.c
$ clang --analyze -Xanalyzer -analyzer-checker=core source.c

# 检查特定类型的漏洞
$ clang --analyze -Xanalyzer -analyzer-checker=security source.c
$ clang --analyze -Xanalyzer -analyzer-checker=alpha.security source.c

# 生成HTML报告
$ clang --analyze -o report.html source.c`}</code>
                </pre>

                <h5 className="font-semibold mb-2">Coverity</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`# 使用Coverity进行代码分析
$ cov-build --dir cov-int make
$ cov-analyze --dir cov-int
$ cov-commit-defects --dir cov-int --url https://scan.coverity.com

# 配置分析选项
$ cov-analyze --dir cov-int --all --enable-constraint-fpp
$ cov-analyze --dir cov-int --enable-fnptr --enable-parse-warnings`}</code>
                </pre>
              </div>

              <h4 className="font-semibold">2. 动态分析工具</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <h5 className="font-semibold mb-2">AFL</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`# 使用AFL进行模糊测试
$ afl-clang-fast -o target target.c
$ afl-fuzz -i testcases -o findings ./target

# 配置AFL选项
$ afl-fuzz -i testcases -o findings -M master ./target
$ afl-fuzz -i testcases -o findings -S slave1 ./target

# 分析结果
$ afl-cmin -i findings -o minimized
$ afl-tmin -i findings/crashes/id:000000 -o minimized`}</code>
                </pre>

                <h5 className="font-semibold mb-2">Valgrind</h5>
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`# 使用Valgrind检测内存问题
$ valgrind --leak-check=full ./program
$ valgrind --tool=memcheck ./program

# 使用其他工具
$ valgrind --tool=helgrind ./program  # 检测线程问题
$ valgrind --tool=drd ./program       # 检测数据竞争
$ valgrind --tool=callgrind ./program # 性能分析`}</code>
                </pre>
              </div>
            </div>
          </div>
        )}

        {activeTab === "practice" && (
          <div className="space-y-6">
            <h3 className="text-xl font-semibold mb-3">实践案例</h3>
            <div className="prose max-w-none">
              <h4 className="font-semibold">1. 缓冲区溢出漏洞分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 漏洞代码示例
void vulnerable_function(char* input) {
    char buffer[64];
    strcpy(buffer, input);  // 缓冲区溢出漏洞
}

// 漏洞利用代码
void exploit() {
    char payload[128];
    // 构造shellcode
    // 覆盖返回地址
    // 执行payload
    vulnerable_function(payload);
}

// 漏洞修复
void fixed_function(char* input) {
    char buffer[64];
    strncpy(buffer, input, sizeof(buffer)-1);
    buffer[sizeof(buffer)-1] = '\\0';
}`}</code>
                </pre>
              </div>

              <h4 className="font-semibold">2. 整数溢出漏洞分析</h4>
              <div className="bg-gray-100 p-4 rounded-lg mb-4">
                <pre className="bg-gray-200 p-2 rounded">
                  <code>{`// 漏洞代码示例
void vulnerable_function(int size) {
    // 整数溢出漏洞
    int* buffer = (int*)malloc(size * sizeof(int));
    if (buffer == NULL) return;
    
    // 使用buffer
    for (int i = 0; i < size; i++) {
        buffer[i] = 0;
    }
    
    free(buffer);
}

// 漏洞利用代码
void exploit() {
    // 触发整数溢出
    int size = INT_MAX / sizeof(int) + 1;
    vulnerable_function(size);
}

// 漏洞修复
void fixed_function(int size) {
    // 检查整数溢出
    if (size <= 0 || size > INT_MAX / sizeof(int)) {
        return;
    }
    
    int* buffer = (int*)malloc(size * sizeof(int));
    if (buffer == NULL) return;
    
    // 使用buffer
    for (int i = 0; i < size; i++) {
        buffer[i] = 0;
    }
    
    free(buffer);
}`}</code>
                </pre>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* 导航链接 */}
      <div className="mt-8 flex justify-between">
        <Link
          href="/study/security/reverse/pack"
          className="px-4 py-2 text-blue-600 hover:text-blue-800"
        >
          ← 加壳脱壳
        </Link>
        <Link
          href="/study/security/reverse/malware"
          className="px-4 py-2 text-blue-600 hover:text-blue-800"
        >
          恶意代码分析 →
        </Link>
      </div>
    </div>
  );
} 